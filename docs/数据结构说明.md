# datas 数据结构说明

## 概述

`datas` 是项目的核心数据容器，贯穿整个流程：数据加载 → 模型训练 → 后验预测 → 后验筛选。

## 数据流程

```
load_data() → datas['train_data']
     ↓
build_model() → 更新 datas['train_data']（添加处理后的特征）
     ↓
train() → datas['trace'], datas['posterior_samples']
     ↓
predict() → datas['S_samples'], datas['P_fan_samples']
     ↓
compute_metrics() → datas['metrics']
     ↓
generate_output() → datas['model_output']
     ↓
filter_posterior() → datas['pfan_filtered'], datas['s_filtered'], datas['week_filter_info']
```

---

## 完整结构

### 1. train_data（训练数据）

```python
datas['train_data'] = {
    # === 维度信息 ===
    'n_obs': int,              # 观测数（所有周的参赛者总数）
    'n_weeks': int,            # 周数
    'n_celebs': int,           # 名人数
    'n_pros': int,             # 专业舞者数
    'n_seasons': int,          # 赛季数

    # === 索引数组 (int32, shape=[n_obs]) ===
    'celeb_idx': np.ndarray,   # 每个观测对应的名人索引
    'pro_idx': np.ndarray,     # 每个观测对应的舞者索引
    'week_idx': np.ndarray,    # 每个观测对应的周索引
    'season_idx': np.ndarray,  # 每个观测对应的赛季索引

    # === 特征矩阵（build_model处理后）===
    'X_celeb': np.ndarray,     # [n_celebs, n_celeb_features] 名人特征
                               # 处理：添加交互项 + 排除exclude_celeb_features
    'X_pro': np.ndarray,       # [n_pros, n_pro_features] 舞者特征（未处理）
    'X_obs': np.ndarray,       # [n_obs, n_obs_features] 观测特征
                               # 处理：添加交互项 + 排除exclude_obs_features + 中心化(可选)
    'X_celeb_names': list,     # 名人特征名（处理后，含交互项名）
    'X_pro_names': list,       # 舞者特征名
    'X_obs_names': list,       # 观测特征名（处理后，含交互项名）

    # === 分离后的线性/样条特征（build_model后添加）===
    'X_lin': np.ndarray,       # [n_obs, n_linear] 线性特征矩阵
    'linear_feature_names': list,  # 线性特征名
    'spline_bases': list,      # [basis_0, basis_1, ...] 观测级样条基矩阵列表
                               # 每个 basis_i: [n_obs, n_basis_dim]
    'spline_feature_names': list,  # 样条特征名（与spline_bases一一对应）
    'celeb_spline_bases': list,    # 名人级样条基矩阵列表
                                   # 每个 basis_i: [n_celebs, n_basis_dim]
    'celeb_spline_feature_names': list,
    'feature_means': np.ndarray,   # 中心化均值（如果启用center_features）

    # === 评委分数据 (float32, shape=[n_obs]) ===
    'judge_score_pct': np.ndarray,    # 百分比法评委分
    'judge_rank_score': np.ndarray,   # 排名法评委分

    # === 周级数据 ===
    'week_data': [
        {
            'obs_mask': np.ndarray,        # bool, [n_obs] 该周参赛者mask
            'eliminated_mask': np.ndarray, # bool, [n_obs] 该周淘汰者mask
            'n_contestants': int,          # 该周参赛者数
            'n_eliminated': int,           # 该周淘汰人数
            'rule_method': int,            # 1=百分比法, 0=排名法
            'judge_save_active': bool,     # 评委拯救是否激活
            'season': int,                 # 赛季号
            'week': int,                   # 周号
        },
        ...  # 共 n_weeks 个
    ]
}
```

### 2. trace（MCMC原始采样结果）

```python
datas['trace'] = {
    # NumPyro MCMC 采样的原始输出
    # shape: [n_samples, ...]
    'alpha': jnp.ndarray,      # [n_samples, n_celebs] 名人效应
    'delta': jnp.ndarray,      # [n_samples, n_pros] 舞者效应
    'beta_obs': jnp.ndarray,   # [n_samples, n_linear] 线性特征系数
    'spline_0_coef': jnp.ndarray,  # [n_samples, n_basis] 第0个样条系数
    'spline_1_coef': jnp.ndarray,  # ...
    'celeb_spline_0_coef': jnp.ndarray,  # 名人级样条系数
    'tau': jnp.ndarray,        # [n_samples] 似然温度参数
    # ... 其他参数
}
```

### 3. posterior_samples（提取的后验样本）

```python
datas['posterior_samples'] = {
    # 从 trace 提取并转换为 numpy 数组
    'alpha': np.ndarray,       # [n_samples, n_celebs] 名人效应
    'delta': np.ndarray,       # [n_samples, n_pros] 舞者效应
    'beta_obs': np.ndarray,    # [n_samples, n_linear] 线性特征系数
    'spline_0_coef': np.ndarray,   # [n_samples, n_basis]
    'spline_1_coef': np.ndarray,
    'celeb_spline_0_coef': np.ndarray,
    'tau': np.ndarray,         # [n_samples]
}
```

### 4. S_samples 和 P_fan_samples（后验预测）

```python
datas['S_samples'] = np.ndarray    # [n_samples, n_obs] 综合得分样本
datas['P_fan_samples'] = np.ndarray  # [n_samples, n_obs] 粉丝投票比例样本
```

### 5. metrics（评估指标）

```python
datas['metrics'] = {
    'week_results': [
        {
            'accuracy': float,         # Acc_B: 后验样本淘汰准确率
            'accuracy_mean': float,    # Acc_A: 点估计淘汰准确率
            'decision_gap': float,     # |Acc_A - Acc_B|
            'p_fan_var': float,        # P_fan后验方差
            'season': int,
            'week': int,
            'season_era': str,         # 'Early'/'Middle'/'Late'
            'judge_save': bool,
            'n_contestants': int,
            'n_eliminated': int,
            'correct_elim_mean': int,  # 点估计正确淘汰数
        },
        ...
    ],
    'mean_accuracy': float,            # 全局 Acc_B
    'mean_accuracy_expectation': float,  # 全局 Acc_A
    'mean_decision_gap': float,
    'mean_p_fan_var': float,
    'n_weeks_evaluated': int,
    'n_eliminations': int,             # 总淘汰次数
}
```

### 6. model_output（模型输出，点估计）

```python
datas['model_output'] = {
    'n_obs': int,
    'n_celebs': int,
    'n_pros': int,
    'celeb_idx': np.ndarray,
    'pro_idx': np.ndarray,
    'week_idx': np.ndarray,

    # 潜在变量（后验均值）
    'mu': np.ndarray,          # [n_obs] 潜在投票强度
    'P_fan': np.ndarray,       # [n_obs] 粉丝投票比例

    # 各组件贡献
    'alpha_contrib': np.ndarray,   # [n_obs] 名人效应贡献
    'delta_contrib': np.ndarray,   # [n_obs] 舞者效应贡献
    'linear_contrib': np.ndarray,  # [n_obs] 线性特征贡献
    'spline_contrib': np.ndarray,  # [n_obs] 样条特征贡献

    # 效应参数（后验均值）
    'alpha': np.ndarray,       # [n_celebs] 名人效应
    'delta': np.ndarray,       # [n_pros] 舞者效应
    'beta_obs': np.ndarray,    # [n_linear] 线性特征系数
    'spline_coefs': list,      # 样条系数列表

    # 特征名映射
    'feature_names': {
        'beta_obs': list,      # 线性特征名
        'splines': list,       # 样条特征名
    },

    # 各线性特征的详细贡献
    'linear_{feature_name}': np.ndarray,  # [n_obs]
    # 各样条特征的详细贡献
    'spline_{feature_name}': np.ndarray,  # [n_obs]
}
```

### 7. 后验筛选结果（filter_posterior后添加）

```python
# P_fan 筛选后分布
datas['pfan_filtered'] = {
    'mean': np.ndarray,        # [n_obs] 筛选后均值
    'std': np.ndarray,         # [n_obs] 筛选后标准差
    'ci_lower': np.ndarray,    # [n_obs] 95% CI下界
    'ci_upper': np.ndarray,    # [n_obs] 95% CI上界
    'n_valid_samples': np.ndarray,  # [n_obs] 有效样本数
}

# S 筛选后分布
datas['s_filtered'] = {
    'mean': np.ndarray,        # [n_obs]
    'std': np.ndarray,
    'ci_lower': np.ndarray,
    'ci_upper': np.ndarray,
    'n_valid_samples': np.ndarray,
}

# 周筛选信息
datas['week_filter_info'] = [
    {
        'season': int,
        'week': int,
        'n_valid': int,        # 有效样本数
        'rate': float,         # 复现率
        'controversial': bool, # 是否为争议周（复现率<1%）
    },
    ...  # 共 n_weeks 个
]
```

### 8. 顶层辅助字段

```python
# train() 后添加的辅助字段（部分与train_data重复，保留兼容性）
datas['feature_means'] = np.ndarray        # 中心化均值
datas['X_obs_names_filtered'] = list       # 处理后的观测特征名
datas['celeb_spline_bases'] = list         # 名人级样条基
datas['celeb_spline_feature_names'] = list
datas['spline_feature_names'] = list
```

---

## 使用示例

### 加载完整结果

```python
from src.utils import load_data

datas = load_data('outputs/results/results.pkl')

# 访问训练数据
train_data = datas['train_data']
n_obs = train_data['n_obs']
X_lin = train_data['X_lin']

# 访问后验样本
posterior = datas['posterior_samples']
alpha = posterior['alpha']  # [n_samples, n_celebs]

# 访问预测结果
P_fan_samples = datas['P_fan_samples']  # [n_samples, n_obs]

# 访问筛选后结果
pfan_mean = datas['pfan_filtered']['mean']
pfan_ci = (datas['pfan_filtered']['ci_lower'], datas['pfan_filtered']['ci_upper'])
```

### 获取特定周的数据

```python
def get_week_data(datas, season, week):
    """获取特定周的数据"""
    train_data = datas['train_data']
    week_data = train_data['week_data']

    for w, wd in enumerate(week_data):
        if wd['season'] == season and wd['week'] == week:
            obs_mask = wd['obs_mask']
            obs_indices = np.where(obs_mask)[0]

            return {
                'week_idx': w,
                'obs_indices': obs_indices,
                'n_contestants': wd['n_contestants'],
                'n_eliminated': wd['n_eliminated'],
                'eliminated_indices': np.where(wd['eliminated_mask'])[0],
                'judge_score': train_data['judge_score_pct'][obs_mask],
                'P_fan_mean': datas['pfan_filtered']['mean'][obs_mask],
                'P_fan_ci': (
                    datas['pfan_filtered']['ci_lower'][obs_mask],
                    datas['pfan_filtered']['ci_upper'][obs_mask]
                ),
                'controversial': datas['week_filter_info'][w]['controversial'],
            }
    return None
```

### 构建对称线性模型的特征矩阵

```python
def build_feature_matrix(datas):
    """构建与贝叶斯模型相同的特征矩阵"""
    td = datas['train_data']

    # 线性特征
    X_lin = td['X_lin']  # [n_obs, n_linear]

    # 样条特征（拼接所有样条基）
    spline_bases = td['spline_bases']
    if spline_bases:
        X_spline = np.hstack(spline_bases)
    else:
        X_spline = np.zeros((td['n_obs'], 0))

    # 合并
    X = np.hstack([X_lin, X_spline])

    # 特征名
    feature_names = list(td['linear_feature_names'])
    for i, name in enumerate(td['spline_feature_names']):
        n_basis = spline_bases[i].shape[1]
        feature_names.extend([f'{name}_spline_{j}' for j in range(n_basis)])

    return X, feature_names
```

---

## 文件保存位置

| 文件 | 内容 | 生成命令 |
|-----|------|---------|
| `outputs/results/results.pkl` | 完整datas（含筛选结果） | `python main.py && python filter_posterior.py` |
| `outputs/results/fold0_results.pkl` | CV第0折结果 | `python main.py`（启用CV） |
| `data/datas.pkl` | 原始预处理数据 | 数据预处理脚本 |

---

## 注意事项

1. **特征处理顺序**：`build_model`会修改`train_data`中的特征（添加交互项、排除特征、中心化），保存的是处理后的版本

2. **样条基矩阵**：`spline_bases`是列表，与`spline_feature_names`一一对应，用于重建样条变换

3. **筛选后数据**：`pfan_filtered`和`s_filtered`是按周筛选后的统计量，争议周使用全部样本

4. **索引对应**：所有`[n_obs]`维度的数组使用相同的观测索引，可通过`week_data[w]['obs_mask']`获取特定周的观测
