# 模型输入说明（内部文档）

## 一、从 datas['train_data'] 获取的数据

### 1.1 维度信息

```python
td = datas['train_data']

n_obs = td['n_obs']         # 观测总数（选手×周）
n_weeks = td['n_weeks']     # 周总数
n_celebs = td['n_celebs']   # 名人总数
n_pros = td['n_pros']       # 舞者总数
n_seasons = td['n_seasons'] # 赛季总数（用于交叉验证）
```

### 1.2 索引数组

```python
celeb_idx = td['celeb_idx']     # [n_obs], int32, 名人ID
pro_idx = td['pro_idx']         # [n_obs], int32, 舞者ID
week_idx = td['week_idx']       # [n_obs], int32, 周ID
season_idx = td['season_idx']   # [n_obs], int32, 赛季ID（用于交叉验证）
```

用途：分层模型中索引随机效应
```python
# 例：获取每个观测对应的名人效应
alpha_celeb = alpha[celeb_idx]  # [n_obs]
```

### 1.3 特征矩阵

```python
X_celeb = td['X_celeb']       # [n_celebs, d_celeb], float32
X_pro = td['X_pro']           # [n_pros, d_pro], float32
X_obs = td['X_obs']           # [n_obs, d_obs], float32

X_celeb_names = td['X_celeb_names']  # list[str]
X_pro_names = td['X_pro_names']      # list[str]
X_obs_names = td['X_obs_names']      # list[str]
```

用途：
- `X_celeb`：名人特征，用于预测名人随机效应的均值
- `X_pro`：舞者特征，用于预测舞者随机效应的均值
- `X_obs`：观测级特征，直接进入 μ 的计算

### 1.4 淘汰规则数据

```python
judge_score_pct = td['judge_score_pct']     # [n_obs], 百分比法用
judge_rank_score = td['judge_rank_score']   # [n_obs], 排名法用
```

用途：计算综合得分 S
```python
# 百分比法 (rule_method=1)
S = judge_score_pct + P_fan

# 排名法 (rule_method=0)
S = judge_rank_score + fan_rank_score
```

### 1.5 周级数据

```python
week_data = td['week_data']  # list[dict], 长度 n_weeks
```

每个 `week_data[w]` 包含：
```python
{
    'obs_mask': np.ndarray,        # [n_obs], bool, 该周参赛选手
    'n_contestants': int,           # 该周人数
    'n_eliminated': int,            # 该周淘汰人数
    'eliminated_mask': np.ndarray,  # [n_obs], bool, 被淘汰选手
    'rule_method': int,             # 0=排名法, 1=百分比法
    'judge_save_active': bool,      # 是否有评委拯救
}
```

用途：似然函数按周计算
```python
for w in range(n_weeks):
    wd = week_data[w]
    mask = wd['obs_mask']
    mu_week = mu[mask]
    P_fan = softmax(mu_week)
    # ...
```

---

## 二、从 config 获取的参数

### 2.1 模型结构

```python
cfg = config['model']

use_student_t = cfg['use_student_t']      # bool
student_t_nu = cfg['student_t_nu']        # float, 自由度

spline_features = cfg['spline_features']  # list[str], 用样条的特征名
n_spline_knots = cfg['n_spline_knots']    # int
spline_degree = cfg['spline_degree']      # int

use_horseshoe = cfg['use_horseshoe']      # bool

tau_init = cfg['tau_init']                # float, PL温度初值
learn_tau = cfg['learn_tau']              # bool

sum_to_zero = cfg['sum_to_zero']          # bool, 随机效应约束
```

### 2.2 先验参数

```python
prior = config['prior']

# 随机效应方差 ~ InvGamma(a, b)
sigma_celeb_a = prior['sigma_celeb']['a']
sigma_celeb_b = prior['sigma_celeb']['b']
sigma_pro_a = prior['sigma_pro']['a']
sigma_pro_b = prior['sigma_pro']['b']

# 系数先验标准差
beta_celeb_scale = prior['beta_celeb_scale']
beta_pro_scale = prior['beta_pro_scale']
beta_obs_scale = prior['beta_obs_scale']
spline_smoothing_scale = prior['spline_smoothing_scale']
```

### 2.3 采样参数

```python
samp = config['sampling']

n_chains = samp['n_chains']
n_tune = samp['n_tune']
n_samples = samp['n_samples']
target_accept = samp['target_accept']
random_seed = samp['random_seed']
cores = samp['cores']
```

### 2.4 输出参数

```python
out = config['output']

output_dir = out['dir']
save_trace = out['save_trace']
```

---

## 三、模型计算流程

### 3.1 计算潜在投票强度 μ

```python
# 1. 名人效应（分层）
alpha_mean = X_celeb @ beta_celeb          # [n_celebs]
alpha = alpha_mean + sigma_celeb * z_celeb # [n_celebs], z~N(0,1)

# 2. 舞者效应（分层）
delta_mean = X_pro @ beta_pro              # [n_pros]
delta = delta_mean + sigma_pro * z_pro     # [n_pros]

# 3. 观测级效应
obs_effect = X_obs @ beta_obs              # [n_obs]
# 或对部分特征用样条
obs_effect = X_obs_lin @ beta_lin + sum(spline_k(X_obs[:, k]))

# 4. 汇总
mu = alpha[celeb_idx] + delta[pro_idx] + obs_effect  # [n_obs]
```

### 3.2 计算粉丝票占比（按周）

```python
for w in range(n_weeks):
    mask = week_data[w]['obs_mask']
    mu_week = mu[mask]
    P_fan = softmax(mu_week)  # 该周粉丝票占比
```

### 3.3 计算综合得分 S

```python
if rule_method == 1:  # 百分比法
    S = judge_score_pct[mask] + P_fan
else:  # 排名法
    fan_rank_score = rank_to_score(P_fan)
    S = judge_rank_score[mask] + fan_rank_score
```

### 3.4 计算似然（Plackett-Luce）

```python
# 淘汰者应该是 S 最低的
eliminated = week_data[w]['eliminated_mask'][mask]
log_lik_w = plackett_luce_min(S, eliminated, tau)
```

---

## 四、待确定事项

1. ~~**样条特征选择**~~：已确定 `z_score`, `weeks_survived`
2. **行业竞争惩罚**：是否加入？公式是什么？
3. **评委拯救逻辑**：`judge_save_active=True` 时如何修改似然？
4. ~~**多人淘汰**~~：已实现顺序 Plackett-Luce

---

## 五、交叉验证

采用**留一赛季法（Leave-One-Season-Out）**：

```python
for test_season in range(n_seasons):
    # 划分数据
    train_mask = (season_idx != test_season)
    test_mask = (season_idx == test_season)

    # 训练
    train_datas = filter_by_mask(datas, train_mask)
    model = build_model(config, train_datas)
    model = train(config, model, train_datas)

    # 评估
    test_datas = filter_by_mask(datas, test_mask)
    metrics = evaluate(model, test_datas)
```

**评估指标**：
- 准确率：正确预测淘汰者的周数 / 总周数
- Brier Score：概率预测校准度
