# 样条特征重建指南

## 概述

本项目使用B样条（B-spline）对连续特征进行非线性变换。样条基矩阵在`build_model`中构建，并保存到`datas['train_data']`中，便于后续重建和对比分析。

## 保存的数据结构

训练完成后，`datas['train_data']`包含以下样条相关信息：

```python
train_data = {
    # === 线性特征 ===
    'X_lin': np.ndarray,           # [n_obs, n_linear] 线性特征矩阵
    'linear_feature_names': list,  # 线性特征名列表

    # === 观测级样条特征 ===
    'spline_bases': list,          # [basis_0, basis_1, ...] 样条基矩阵列表
                                   # 每个 basis_i: [n_obs, n_basis_dim]
    'spline_feature_names': list,  # 样条特征名（与spline_bases一一对应）

    # === 名人级样条特征 ===
    'celeb_spline_bases': list,    # [basis_0, ...] 名人级样条基矩阵
                                   # 每个 basis_i: [n_celebs, n_basis_dim]
    'celeb_spline_feature_names': list,

    # === 其他 ===
    'feature_means': np.ndarray,   # 中心化均值（如果启用center_features）
}
```

## 样条基矩阵说明

### 构建方式

样条基矩阵使用`patsy`库的`bs()`函数构建：

```python
from patsy import dmatrix
import numpy as np

def _build_spline_basis(x, n_knots, degree):
    """构建B样条基矩阵"""
    knots = np.linspace(x.min(), x.max(), n_knots)
    basis = dmatrix(
        f"bs(x, knots={list(knots[1:-1])}, degree={degree}, include_intercept=False) - 1",
        {"x": x}, return_type='dataframe'
    )
    return np.asarray(basis, dtype=np.float32)
```

### 参数说明

- `n_knots`: 节点数量（配置文件中的`model.n_spline_knots`）
- `degree`: 样条阶数（配置文件中的`model.spline_degree`，通常为3表示三次样条）
- 节点位置：在特征值范围`[x.min(), x.max()]`内均匀分布

### 基矩阵维度

对于`n_knots`个节点和`degree`阶样条，基矩阵的列数为：
```
n_basis_dim = n_knots + degree - 2
```

例如：`n_knots=5, degree=3` → `n_basis_dim = 5 + 3 - 2 = 6`

## 使用场景

### 场景1：训练对称的线性模型

使用与贝叶斯模型完全相同的特征形式训练线性模型，便于权重对比：

```python
import numpy as np
from sklearn.linear_model import LinearRegression
from src.utils import load_data

# 加载数据
datas = load_data('outputs/results/results.pkl', {})
td = datas['train_data']

# 构建特征矩阵（与贝叶斯模型相同）
# 1. 线性特征
X_lin = td['X_lin']  # [n_obs, n_linear]

# 2. 样条特征（拼接所有样条基）
spline_bases = td['spline_bases']
if spline_bases:
    X_spline = np.hstack(spline_bases)  # [n_obs, total_spline_dim]
else:
    X_spline = np.zeros((td['n_obs'], 0))

# 3. 合并为完整特征矩阵
X = np.hstack([X_lin, X_spline])

# 目标变量
y = td['judge_score_pct']

# 训练
model = LinearRegression()
model.fit(X, y)

# 提取权重
n_linear = X_lin.shape[1]
linear_weights = model.coef_[:n_linear]
spline_weights = model.coef_[n_linear:]
```

## 与贝叶斯模型的对应关系

贝叶斯模型中的特征贡献：

```
μ = α[celeb_idx] + δ[pro_idx] + X_lin @ β_obs + Σ(spline_basis_i @ spline_coef_i)
```

对应的数据结构：

| 模型组件 | 数据位置 | 说明 |
|---------|---------|------|
| `α` | `posterior_samples['alpha']` | 名人效应 [n_samples, n_celebs] |
| `δ` | `posterior_samples['delta']` | 舞者效应 [n_samples, n_pros] |
| `β_obs` | `posterior_samples['beta_obs']` | 线性特征系数 [n_samples, n_linear] |
| `X_lin` | `train_data['X_lin']` | 线性特征矩阵 [n_obs, n_linear] |
| `spline_coef_i` | `posterior_samples['spline_i_coef']` | 第i个样条系数 |
| `spline_basis_i` | `train_data['spline_bases'][i]` | 第i个样条基矩阵 |

## 注意事项

1. **节点位置一致性**：对新数据应用样条变换时，必须使用训练数据的节点位置，否则基矩阵不可比
2. **特征顺序**：`spline_bases`列表与`spline_feature_names`一一对应
3. **中心化**：如果启用了`center_features`，`X_lin`已经是中心化后的值，`feature_means`保存了均值
